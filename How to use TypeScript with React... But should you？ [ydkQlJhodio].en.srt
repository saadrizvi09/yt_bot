1
00:00:00,000 --> 00:00:03,540
when I started this YouTube channel four

2
00:00:01,680 --> 00:00:04,859
years ago most react developers would

3
00:00:03,540 --> 00:00:07,020
have laughed at the idea of using

4
00:00:04,859 --> 00:00:09,120
something like typescript you should

5
00:00:07,020 --> 00:00:10,320
you should nah bro like why would you

6
00:00:09,120 --> 00:00:11,880
take your beautiful functional

7
00:00:10,320 --> 00:00:13,440
JavaScript and bloat it with a bunch of

8
00:00:11,880 --> 00:00:15,420
type definitions that make it look like

9
00:00:13,440 --> 00:00:17,100
the real Jabba I was very skeptical of

10
00:00:15,420 --> 00:00:19,619
it myself when I first started using it

11
00:00:17,100 --> 00:00:21,060
in an angular project in 2017. now maybe

12
00:00:19,619 --> 00:00:23,100
it's just the Stockholm syndrome talking

13
00:00:21,060 --> 00:00:24,359
but after using it I've never wanted to

14
00:00:23,100 --> 00:00:25,920
go back but I don't think I'm alone

15
00:00:24,359 --> 00:00:28,080
because it was the second most loved

16
00:00:25,920 --> 00:00:29,760
technology on the 2020 stack Overflow

17
00:00:28,080 --> 00:00:30,960
survey in today's video you'll learn

18
00:00:29,760 --> 00:00:32,880
everything you need to know to get

19
00:00:30,960 --> 00:00:34,860
started with typescript and react but

20
00:00:32,880 --> 00:00:36,239
more importantly we'll talk about why or

21
00:00:34,860 --> 00:00:37,980
why not you should use it because

22
00:00:36,239 --> 00:00:39,420
there's a good case to be made for both

23
00:00:37,980 --> 00:00:41,160
sides of that argument if you're new

24
00:00:39,420 --> 00:00:43,320
here like And subscribe and become a pro

25
00:00:41,160 --> 00:00:45,780
member at fireship i o to get access to

26
00:00:43,320 --> 00:00:46,620
my full next JS react course to decide

27
00:00:45,780 --> 00:00:48,180
whether or not you want to use

28
00:00:46,620 --> 00:00:50,100
typescript let's take a look at two

29
00:00:48,180 --> 00:00:51,960
different projects side by side one with

30
00:00:50,100 --> 00:00:53,520
typescript and one without there are

31
00:00:51,960 --> 00:00:55,620
many different ways to add typescript to

32
00:00:53,520 --> 00:00:57,899
a react app in this case I'm using the

33
00:00:55,620 --> 00:00:59,820
create react app tool but specifying the

34
00:00:57,899 --> 00:01:01,379
typescript template the docs also have

35
00:00:59,820 --> 00:01:03,059
instructions for adding it to an

36
00:01:01,379 --> 00:01:05,220
existing project or you can learn how to

37
00:01:03,059 --> 00:01:06,600
set it up in next.js in my course if we

38
00:01:05,220 --> 00:01:08,700
look at the file system on these two

39
00:01:06,600 --> 00:01:10,020
projects side by side the most obvious

40
00:01:08,700 --> 00:01:12,780
difference is that the typescript

41
00:01:10,020 --> 00:01:15,119
project has files ending in dot TS or

42
00:01:12,780 --> 00:01:16,860
dot TSX but the weird thing is that if

43
00:01:15,119 --> 00:01:18,659
we look inside one of these files the

44
00:01:16,860 --> 00:01:20,280
code is exactly the same as the

45
00:01:18,659 --> 00:01:22,200
Javascript file and that actually brings

46
00:01:20,280 --> 00:01:24,000
up a good question what is typescript if

47
00:01:22,200 --> 00:01:25,920
my code is exactly the same typescript

48
00:01:24,000 --> 00:01:27,840
as a language is a superset of

49
00:01:25,920 --> 00:01:30,900
JavaScript that means vanilla JavaScript

50
00:01:27,840 --> 00:01:32,820
is also 100 valid typescript in other

51
00:01:30,900 --> 00:01:34,680
words it just adds extra optional

52
00:01:32,820 --> 00:01:37,920
features on top of regular JavaScript

53
00:01:34,680 --> 00:01:39,780
the relationship between scss and CSS is

54
00:01:37,920 --> 00:01:41,400
the same as typescript and JavaScript

55
00:01:39,780 --> 00:01:42,479
and that's really cool because it means

56
00:01:41,400 --> 00:01:44,460
you don't really have to learn anything

57
00:01:42,479 --> 00:01:46,560
to get started with it but here's the

58
00:01:44,460 --> 00:01:48,899
catch browsers don't know how to run

59
00:01:46,560 --> 00:01:50,880
typescript code what is this crap which

60
00:01:48,899 --> 00:01:53,399
means that we need a compiler to take

61
00:01:50,880 --> 00:01:55,740
our typescript code and transpile it or

62
00:01:53,399 --> 00:01:57,600
compile it down to regular JavaScript in

63
00:01:55,740 --> 00:02:00,540
our TS project you'll notice a special

64
00:01:57,600 --> 00:02:02,520
file called tsconfig its purpose is to

65
00:02:00,540 --> 00:02:04,200
customize the behavior of the compiler

66
00:02:02,520 --> 00:02:06,180
which itself is able to take your

67
00:02:04,200 --> 00:02:07,799
typescript code and convert it to any

68
00:02:06,180 --> 00:02:09,780
flavor of JavaScript trip that you want

69
00:02:07,799 --> 00:02:11,160
to run in the browser compilers are

70
00:02:09,780 --> 00:02:12,780
really cool because they allow you to

71
00:02:11,160 --> 00:02:14,700
use special features and modern

72
00:02:12,780 --> 00:02:16,020
JavaScript syntax without having to

73
00:02:14,700 --> 00:02:18,060
worry whether or not that code is going

74
00:02:16,020 --> 00:02:19,800
to be supported on Old Legacy browsers

75
00:02:18,060 --> 00:02:21,360
the drawback is that you now have this

76
00:02:19,800 --> 00:02:23,400
giant configuration file to worry about

77
00:02:21,360 --> 00:02:24,840
normally everything just works but when

78
00:02:23,400 --> 00:02:26,099
it doesn't you have to Google all these

79
00:02:24,840 --> 00:02:28,020
different options and figure out what

80
00:02:26,099 --> 00:02:29,940
they do many of the options are related

81
00:02:28,020 --> 00:02:31,560
to how strict typescript is with its

82
00:02:29,940 --> 00:02:33,180
type checking rules and I'd highly

83
00:02:31,560 --> 00:02:35,160
recommend making it as strict as

84
00:02:33,180 --> 00:02:36,959
possible by putting strict mode to True

85
00:02:35,160 --> 00:02:38,519
that'll make your code initially more

86
00:02:36,959 --> 00:02:40,500
difficult to write but in the long run

87
00:02:38,519 --> 00:02:42,540
it makes refactoring and collaborating

88
00:02:40,500 --> 00:02:44,340
with other developers way easier another

89
00:02:42,540 --> 00:02:45,959
important option is Target which is the

90
00:02:44,340 --> 00:02:48,480
flavor of JavaScript that typescript

91
00:02:45,959 --> 00:02:50,879
will compile your code to es5 is the

92
00:02:48,480 --> 00:02:53,280
2009 version of JavaScript but your code

93
00:02:50,879 --> 00:02:54,660
base can write 2021 JavaScript sounds

94
00:02:53,280 --> 00:02:56,819
amazing but do you really need

95
00:02:54,660 --> 00:02:58,739
typescript to do that under the hood the

96
00:02:56,819 --> 00:03:01,080
JavaScript version of create react app

97
00:02:58,739 --> 00:03:02,940
uses a compiler called Babel that does

98
00:03:01,080 --> 00:03:04,800
the exact same thing so the bottom line

99
00:03:02,940 --> 00:03:07,739
is that you can write modern code in

100
00:03:04,800 --> 00:03:08,819
both a react.js or TS project now one

101
00:03:07,739 --> 00:03:10,500
thing you'll often hear typescript

102
00:03:08,819 --> 00:03:12,540
developers say is that it helps them

103
00:03:10,500 --> 00:03:14,519
catch silly bugs in development before

104
00:03:12,540 --> 00:03:16,620
they become huge disasters in production

105
00:03:14,519 --> 00:03:18,180
let's take a look at an example to see

106
00:03:16,620 --> 00:03:20,220
if that's true or not in the JavaScript

107
00:03:18,180 --> 00:03:22,260
project I have some state that starts

108
00:03:20,220 --> 00:03:24,300
off as an empty object now somewhere

109
00:03:22,260 --> 00:03:26,459
else I might reference that object and

110
00:03:24,300 --> 00:03:28,260
try to access a deeply nested property

111
00:03:26,459 --> 00:03:30,000
on it that looks like valid code but

112
00:03:28,260 --> 00:03:31,860
when we run the app we get an error that

113
00:03:30,000 --> 00:03:33,299
it cannot read that property bugs like

114
00:03:31,860 --> 00:03:34,860
this get shipped to production all the

115
00:03:33,299 --> 00:03:37,140
time but if we try to do the same thing

116
00:03:34,860 --> 00:03:38,640
in typescript it's like a goddamn precog

117
00:03:37,140 --> 00:03:40,319
that lets us know the error exists

118
00:03:38,640 --> 00:03:42,120
before the app even runs I really

119
00:03:40,319 --> 00:03:44,040
appreciate that because I make silly

120
00:03:42,120 --> 00:03:45,540
mistakes like that all the time but keep

121
00:03:44,040 --> 00:03:47,459
in mind that it doesn't replace test

122
00:03:45,540 --> 00:03:49,140
driven development it can detect poorly

123
00:03:47,459 --> 00:03:51,180
structured code in advance but can't

124
00:03:49,140 --> 00:03:52,739
detect batlogic but now let's look at

125
00:03:51,180 --> 00:03:55,260
the most important feature of typescript

126
00:03:52,739 --> 00:03:56,819
its type system and the pros and cons of

127
00:03:55,260 --> 00:03:58,620
using it if we build a functional

128
00:03:56,819 --> 00:04:01,319
component in JavaScript you'll notice

129
00:03:58,620 --> 00:04:03,120
that it has a type of jsx element in

130
00:04:01,319 --> 00:04:05,280
addition if we reference props they

131
00:04:03,120 --> 00:04:07,140
automatically have a type of any that's

132
00:04:05,280 --> 00:04:08,939
a pretty vague type definition overall

133
00:04:07,140 --> 00:04:10,980
in typescript we can be much more

134
00:04:08,939 --> 00:04:13,439
explicit about what our code actually is

135
00:04:10,980 --> 00:04:15,420
react has a built-in type called FC

136
00:04:13,439 --> 00:04:17,100
which stands for function component and

137
00:04:15,420 --> 00:04:19,620
we can assign that type to the component

138
00:04:17,100 --> 00:04:21,060
using a colon followed by the type that

139
00:04:19,620 --> 00:04:22,560
tells the compiler the shape of this

140
00:04:21,060 --> 00:04:24,360
code which will throw an error for

141
00:04:22,560 --> 00:04:26,580
anything that's not a valid prop and

142
00:04:24,360 --> 00:04:28,680
autocomplete everything else by default

143
00:04:26,580 --> 00:04:30,600
the only known react prop is children

144
00:04:28,680 --> 00:04:33,060
but we can Define the shape of our own

145
00:04:30,600 --> 00:04:34,860
props using a typescript interface an

146
00:04:33,060 --> 00:04:37,199
interface allows you to define the shape

147
00:04:34,860 --> 00:04:39,360
of an object by matching a property name

148
00:04:37,199 --> 00:04:41,220
to a type like here we have an interface

149
00:04:39,360 --> 00:04:43,020
called cool props that should be an

150
00:04:41,220 --> 00:04:45,300
object with two properties one of which

151
00:04:43,020 --> 00:04:46,979
is a number and the other a string in

152
00:04:45,300 --> 00:04:48,840
its current form the interface will make

153
00:04:46,979 --> 00:04:50,880
these properties required on the object

154
00:04:48,840 --> 00:04:52,620
but you can make them optional by adding

155
00:04:50,880 --> 00:04:54,840
a question mark after the property name

156
00:04:52,620 --> 00:04:56,880
we can now take this interface and pass

157
00:04:54,840 --> 00:04:58,740
it to the function component type by

158
00:04:56,880 --> 00:05:00,360
wrapping it in angle brackets this is

159
00:04:58,740 --> 00:05:02,039
like saying we have a function component

160
00:05:00,360 --> 00:05:03,600
that also includes props of its own

161
00:05:02,039 --> 00:05:05,580
custom shape and now we get really

162
00:05:03,600 --> 00:05:07,080
useful intellisense on any props when

163
00:05:05,580 --> 00:05:09,000
working with this component and it also

164
00:05:07,080 --> 00:05:10,620
guarantees that we use the required

165
00:05:09,000 --> 00:05:13,139
props when working with this component

166
00:05:10,620 --> 00:05:14,940
in jsx however that did come at a pretty

167
00:05:13,139 --> 00:05:16,560
significant cost we've added a lot of

168
00:05:14,940 --> 00:05:18,360
boilerplate to the code base without

169
00:05:16,560 --> 00:05:20,639
adding any new functionality for the

170
00:05:18,360 --> 00:05:22,320
user now it is possible to bypass type

171
00:05:20,639 --> 00:05:24,300
checking whenever you want by simply

172
00:05:22,320 --> 00:05:26,340
adding the any type that allows you to

173
00:05:24,300 --> 00:05:27,900
opt out of typescript but also negates

174
00:05:26,340 --> 00:05:29,580
all of its benefits it's also worth

175
00:05:27,900 --> 00:05:31,500
noting that typescript can provide

176
00:05:29,580 --> 00:05:33,300
automatic documentation for your code

177
00:05:31,500 --> 00:05:35,400
because your editor will automatically

178
00:05:33,300 --> 00:05:37,440
pick up the type definitions so anybody

179
00:05:35,400 --> 00:05:39,180
using your code will get intellisense on

180
00:05:37,440 --> 00:05:40,919
the shape and purpose of it and that's

181
00:05:39,180 --> 00:05:43,500
way way more efficient than having to go

182
00:05:40,919 --> 00:05:45,360
read some documentation online now in

183
00:05:43,500 --> 00:05:47,639
many cases typescript can automatically

184
00:05:45,360 --> 00:05:49,560
infer the type without you having to add

185
00:05:47,639 --> 00:05:51,479
any additional code to the code base for

186
00:05:49,560 --> 00:05:53,639
example you might want to strongly type

187
00:05:51,479 --> 00:05:55,259
the use statehook however the angle

188
00:05:53,639 --> 00:05:57,180
brackets may not be necessary here

189
00:05:55,259 --> 00:05:58,680
because if you have a default value of a

190
00:05:57,180 --> 00:06:00,419
string you don't need to give it an

191
00:05:58,680 --> 00:06:02,400
explicit type it'll have a string type

192
00:06:00,419 --> 00:06:04,020
automatically and if you try to change

193
00:06:02,400 --> 00:06:05,940
it to a value that's not a string you'll

194
00:06:04,020 --> 00:06:07,560
get that precog error in vs code so

195
00:06:05,940 --> 00:06:09,060
that's pretty nice but is typescript

196
00:06:07,560 --> 00:06:10,979
really worth it it's managed by

197
00:06:09,060 --> 00:06:12,360
Microsoft Enterprise loves it but some

198
00:06:10,979 --> 00:06:14,520
guy on the internet said it only catches

199
00:06:12,360 --> 00:06:16,319
15 percent of bugs while Airbnb said it

200
00:06:14,520 --> 00:06:17,639
catches 38 percent of bugs would you

201
00:06:16,319 --> 00:06:19,139
rather write more code or would you

202
00:06:17,639 --> 00:06:20,520
rather be more confident in the code you

203
00:06:19,139 --> 00:06:22,139
do write would you rather look at your

204
00:06:20,520 --> 00:06:23,639
documentation on a website or would you

205
00:06:22,139 --> 00:06:24,900
rather have it be automatic in your

206
00:06:23,639 --> 00:06:26,520
editor would you rather write faster

207
00:06:24,900 --> 00:06:28,139
code now or deal with chaotic

208
00:06:26,520 --> 00:06:29,940
refactoring later do your friends and

209
00:06:28,139 --> 00:06:30,960
family love it or do they hate it these

210
00:06:29,940 --> 00:06:32,880
are all trade-offs that you need to

211
00:06:30,960 --> 00:06:34,800
think about but in my opinion the answer

212
00:06:32,880 --> 00:06:37,639
to should you use typescript with react

213
00:06:34,800 --> 00:06:37,639
is obviously

